### Перечисления

Перечисления - специальный тип данных, который содержит набор констант.
Пример: 
```C++
enum class Color {
	White,
	Red,
	Orange,
	Blue,
};
```
Мы описали тип данных `Color`. При помощи префикса можем обращаться к нему:
```C++
int main(){
	Color color1 = Color::Red;
	Color color2 = Color::Blue;
}
```
Через оператор `static_cast<>` можно привести другие типы к типу `Color` и обратно.

### Структуры
Когда необходимо собрать несколько переменных под одной, то можно создать структуру.
```C++
struct Point {
	double x;
	double y;
	double z;
	Color color;
};
```
Примеры взаимодействия со структурой:
```C++
int main(){
	Point point1;
	point1.color = Color::Blue;

	Point point2 = {1.2, 4.2, 0.4, Red};
	point.z = 3;
	point.x += 2.0;
	// В C++20 появилась новая форма инициализации структуры под названием designated initializers
	Point point3 = {.x = 1.2, .y = 4.2, .z = 2.0}; // Не заполненные поля заполнятся нулевыми значениями, тоесть .color = Color::White
	Point point4 = {.color = Red};
}
```

### Выравнивание
```C++
int main() { 
	std::cout << sizeof(double) << "\n"; // 8 
	std::cout << sizeof(Color) << "\n"; // 4 (фактически это int) 
	std::cout << sizeof(Point) << "\n"; // 32 
}
```
Хотя если посчитать размеры полей у структуры, то получится 28. А всё дело в том, что происходит выравнивание, когда компилятор резервирует такое количество байт, что общий размер будет кратен 8, так как в структуре есть поля с размером 8 байт.
![[Pasted image 20250126220912.png]]

При этом можно отключить резервирование байтов, но тогда пострадает скорость работы программы.

### Кортежи и пары

В заголовочном файле `utility` есть шаблонная структура `std::pair` с полями `first` и `second`.
```C++
#include <utility>
#include <iostream>

int main(){
	std::pair<int, double> p = {1, 3.14};
	std::cout << p.first << std::endl;
	std::cout << p.second << std::endl;
	return 0;
}
```

Обобщением пары на несколько переменных является кортеж - `std::tuple`, который содержится в заголовочном файле `tuple`.
```C++
#include <tuple>
#include <iostream>

int main() {
	std::tuple<int, double, Point> t = {42, 3.14, {.color = Red}};
	// Тут уже нет полей, поэтому используем оператор std::get<index>(x)
	std::cout << std::get<0>(t) << "\n"; // 42
	std::cout << std::get<1>(t) << "\n"; // 3.14
	std::cout << std::get<2>(t).x << "\n" // 0.0
	// вызов std::get может появляться и слева от присваивания:
	std::get<2>(t).color = Color::Red;
}
```
Типы и размер кортежа фиксируются на момент компиляции.
Также кортеж, пару и структуры можно "распаковать":
```C++
#include <utility>
#include <string>

int main(){
	std::pair<std::string, int> p = {"lalala", 666};
	auto [word, age] = p;
}

```
