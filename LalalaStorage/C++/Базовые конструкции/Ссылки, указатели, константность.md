### Копии переменных
В отличии от других языков программирования в C++ при инициализации переменной при помощи другой переменной, происходит её копирование, то есть под неё выделяется память и содержимое первой переменной копируется туда, следовательно, новая переменная никак не связана с первой переменной.
### Ссылки
В C++ есть возможность обращаться к переменной через другую при помощи ссылок:
```C++
#include <iostream>

int main(){
	int a = 42;
	int& ref = a; // ссылка на a

	++a;
	std::cout << ref << "\n"; // 43
	return 0;
}
```
Здесь `ref` - псевдоним для `x`. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом `ref` является `int&` - ссылка на `int`.
Свойства:
- Ссылка должна быть сразу проинициализирована после объявления;
- Изменить ссылку после инициализации нельзя;
### Указатели
Есть ещё один способ сослаться на уже существующий объект в памяти - указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти.
```C++
#include <iostream>

int main(){
	int x = 42;
	int* ptr = &x;
	++x;

	std::cout << *ptr << "\n"; // 43
	return 0;
}
```

![[Pasted image 20250126225237.png]]
Формально, указатель это не номер ячейки памяти, а отдельный тип, но обычно он может быть преобразован в целое число.
```C++
int main(){
	int x = 1, y = 2, z = 3;
	std::cout << &x << "\n";
	std::cout << &y << "\n";
	std::cout << &z << "\n";
	return 0;
}
```
Вывод:
```
0x7ffdfee3188c
0x7ffdfee31888
0x7ffdfee31884
```

Как можно заметить адреса идут с шагом `sizeof(int)` по возрастанию или убыванию, всё зависит от платформы или компилятора.

Указатель помимо адреса имеет тип данных, адрес которого он хранит, что позволяет компилятору правильно интерпретировать обращение к памяти.

Оператор разыменовывания (`*`) является противоположностью оператору взятия адреса (`&`).

Указатели, в отличии от ссылок, можно изменять, кроме того есть выделенное значение никуда не ссылающегося указателя - `nullptr`.
Разыменовывать указатель со значением `nullptr` нельзя, так как это приведёт к неопределённому поведению.

Часто указатели используют вместе с динамической памятью.

Для обращения к полям структуры через указатель существует отдельный оператор `->`
```C++
#include <iostream>

struct Point { double x, y, z; };

int main() {
	Point p = {3.0, 4.0, 5.0};
	Point* ptr = &p;
	std::cout << (*ptr).x << "\n"; // 3.0
	std::cout << ptr->x << "\n"; // 3.0
	return 0;
}
```
### Константность
Константа — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:
```C++
#include <iostream>

int main() {
	const int c1 = 42; // Значение известно во время compile time
	int x;
	cin >> x;
	const int c2 = x * 2; // Значение будет известно только во время runtime 
	c2 = 0; // Ошибка компиляции
}
```
У константного вектора или строки нельзя использовать методы, которые меняют объект.
Ссылки и указатели можно комбинировать с константностью:

```C++
#include <iostream>

int main() {
	int x = 666;

	int& ref = x; // Обычная ссылка
	const int& cref = x; // Константная ссылка
	++x; // OK
	++ref; // OK
	++cref // ERROR

	int* ptr = &x;
	const int* cptr = &x;
	++*ptr; // OK
	++*cptr; // ERROR
}
```

Если исходная переменная является константной, то можно создать только константную ссылку или указатель.

Базовый тип и слово `const` можно менять местами. Так что `T const` или `const T` - это одно и то же. Но следует различать `T* const`(константу типа указатель) и `const T*`(указатель на константу)
```C++
#include <iostream>

int main() {
	int x = 666;
	const int cx = 13;

	int* ptr = &x; // обычный указатель
	ptr = &cx; // Ошибка компиляции

	const int* cptr = &x; // OK через *cptr нельзя изменить x;
	cptr = &cx // OK

	int* const ptrc = &x; // OK *ptrc можно менять, но ptrc менять нельзя
	ptrc = nullptr; // ERROR

	const int* const cptrc = &x; // OK
}
```

`cptrc` является константным указателем на константную переменную.

### Ссылки в цикле

Давайте рассмотрим одну программу:
```C++
#include <iostream>
#include <vector>
int main() {
// создаём вектор из m строк длины n 
// и искусственно заполняем его: 
	const size_t m = 1000000;
	const size_t n = 10000; 
	std::vector<std::string> v(m); 
	for (size_t i = 0; i != m; ++i) {
		 v[i].resize(n, '@'); // кладём в вектор строку из n символов @ 
	} 
	// нам интересен этот цикл: 
	size_t sum = 0;
	for (auto row : v) {
		 sum += row.size();
	} 
	std::cout << sum << "\n";
	return 0;
}
```

Если скомпилировать программу с флагом `-O2` и измерим её время работы.

Можно узнать, что `for (auto row : v)` аналогично `for (int i = 0; i < v.size(); ++i)`

Вместо этого можно использовать константные ссылки
```C++
for (const auto& row : v) {
	...
}
```
Теперь программа ускориться, так как мы не тратим время на копирование.

### «Висячие» ссылки и указатели
Может оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и ссылками. В таком случае обращаться к адресу нельзя, так как это приведёт к неопределённому поведению.
