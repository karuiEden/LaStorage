
Вектор (`std::vector`) и строка (`std::string`) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.

## Векторы

В стандартной библиотеке C++ вектором называется динамический массив, который обеспечивает быстрое добавление в конец и изменение размера при необходимости.

Заголовочный файл `<vector>`

Вектор может хранить элементы только одного типа. Сам `std::vector` называется  *шаблоном*, так как для его работы требуется указать параметры(в случае вектора указать его тип).

Вектор всегда резервирует место для элементов, но после того как резерв кончается, то происходит реаллокация. Текущую ёмкость вектора можно узнать при помощи метода `capacity`

Доступные методы:
```C++
#include <vector>
#include <iostream>
using namespace std;

int main(){
	vector<int> data = {1, 2, 3, 4, 5};
	cout >> data[0] >> "\n"; // 1
	cout >> data.size() >> "\n"; // 5
	cout >> data.front() >> "\n" //  1 = data[0]
	cout >> data.back() >> "\n" // 5 = data[data.size() - 1]
	cout >> data.empty() >> "\n" // false (проверяет пустой ли вектор)
	cout >> data.at(0) >> "\n" // 1 (индексация с проверкой)
	cout >> data.at(100) >> "\n" // out_of_range
	cout >> data.capacity() >> "\n" // Показывает ёмкость вектора
	cout >> data.reserve(n) >> "\n" // Меняет резерв вектора на n
	cout >> data.resize(n) >> "\n" // Меняет размер вектора на n(если data.size < n, то добавляются 0, в ином случае последние элементы удаляются)
	
	cout >> data.ssize() >> "\n" // Возвращает знаковый размер вектора
	data.push_back(6) // Добавляет в конец элемент со значением 6
	data.pop_back() // Удаляет последний элемент
	data.clear() // Очищает весь вектор
	return 0;
}
```

Также можно создать многомерный массив, его можно создать следующим образом. Для примера, создадим матрицу:
```C++
#include <vector>

int main(){
	int m, n;
	m = 4;
	n = 3;
	std::vector<std::vector<int>> matrix(m, std::vector<int>(n)); // Матрица из m строк и n столбов, состоящая из 0
}
```

### Сортировка

Заголовочный файл `<algorithm>`, в котором есть функция `sort`. Гарантируется, что сложность её работы в худшем случае составит $O(n\log n)$ . В функцию передаются итераторы, которые возвращают методы `begin` и `end`, также есть обратные итераторы `rbegin` и `rend`.
 В стандарте C++ 2020 появился новый способ сортировки `std::ranges::sort`, где уже нужен лишь сам вектор.
## Строки

Контейнер `std::string` можно рассмотреть как частный случай `std::vector<char>` , имеющий дополнительный набор функций.
```C++
#include <string>
#include <iostream>

int main(){
	std::string s = "Some string"
	s += ' '; // Добавление символа в конец строки.
	s += "functions"; // Добавление строки в конец
	std::cout << s << "\n"; // "Some string functions"
	std::string sub1 = s.substr(5,6) // Подстрока из 6 символов, начиная с 5 символа.
	size_t pos = s.find(' ', 0) // позиция первого пробела, если элемент не находится, то функция возвращает std::string::npos
	s.insert(5, "std::"); // Вставка подстроки
	s.replace(0,4, "Special") // Замена диапазона строки на подстроку
	s.erase(0,4) // Удаление подстроки
	// В C++20 появились новые функции для работы со строками.
	s.starts_with("Hello") // Проверяет префикс строки
	s.ends_with("World") // Проверяет суффикс строки
}
```