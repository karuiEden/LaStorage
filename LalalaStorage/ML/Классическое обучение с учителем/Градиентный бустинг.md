---
title: Градиентный бустинг
created: 2025-10-04
tags:
  - ml
  - ensemble
links:
---
## Бустинг в задаче регрессии

Рассмотрим задачу минимизации квадратичного функционала:
$$\frac{1}{2}\sum_{i=1}^{\ell}(a(x_{i})-y_{i})^{2}\to \min_{a}$$
Будем искать итоговый алгоритм в виде суммы *базовых моделей* ($\text{weak learners}$) $b_{n}(x)$:
$$a_{N}(x)= \sum_{n=1}^{N}b_{n}(x),$$
где базовые алгоритмы $b_{n}(x)$ принадлежат некоторому семейству $\mathcal{A}$.

Построим первый базовый алгоритм:
$$b_{1}(x):= \arg_{b\in \mathcal{A}}\min \frac{1}{2}(b(x_{i})-y_{i})^{2}$$
Решение такой задачи не представляет трудностей для многих семейств алгоритмов. Теперь мы можем посчитать остатки на каждом объекте - расстояния от ответа нашего алгоритма до истинного ответа:
$$s_{i}^{(1)}=y_{i}-b_{1}(x_{i})$$
Если прибавить эти остатки к ответам построенного алгоритма, то он не будет допускать ошибок на обучающей выборке. Значит, будет разумно построить второй алгоритм так, чтобы его ответы были как можно ближе к остаткам:
$$b_{2}(x):=\arg_{b\in \mathcal{A}}\min \frac{1}{2}\sum_{i=1}^{\ell}(b(x_{i})-s_{i}^{(1)})^{2}$$
Каждый следующий алгоритм тоже будем настраивать на остатки предыдущих:
$$s_{i}^{(N)}=y_{i}-\sum_{n=1}^{N-1}b_{n}(x_{i})=y_{i}-a_{N-1}(x_{i}), \ \ \ i=1,\dots,\ell ;$$
$$b_{N}(x):=\arg_{b\in \mathcal{A}}\min \frac{1}{2}\sum_{i=1}^{\ell}(b(x_{i})-s_{i}^{(N)})^{2}$$
Описанный метод прост в реализации, хорошо работает и может быть найден во многих библиотеках - например, в $\text{scikit-learn}$.

Заметим, что остатки могут быть найдены как антиградиент функции потерь по ответу модели, посчитанный в точке ответа уже построенной композиции:
$$s_{i}^{(N)}=y_{i}-a_{N-1}(x_{i})= - \frac{\partial}{\partial z} \frac{1}{2}(z-y_{i})^{2}\bigg|_{z=a_{N-1}(x_{i})}$$
Получается, что выбирается такой базовый алгоритм, который как можно сильнее уменьшит ошибку композиции - это свойство вытекает из его близости к антиградиенту функционала на обучающей выборке. 
## Градиентный бустинг

Пусть дана некоторая дифференцируемая функция потерь $L(y,z)$. Будем строить взвешенную сумму базовых алгоритмов:
$$a_{N}(x)=\sum_{n=0}^{N}\gamma_{n}b_{n}(x)$$
Заметим, что в композиции имеется начальный алгоритм $b_{0}(x)$. Как правило, коэффициент $\gamma_{0}$ при нем берут равным единице, а сам алгоритм выбирают очень простым, например:
- нулевым $b_{0}(x)=0;$
- возвращающим самый популярный класс (в задачах классфикации):
	$$b_{0}(x)=\arg_{y\in \mathbb{Y}}\max \sum_{i=1}^{\ell}[y_{i}=y]$$
- возвращающим средний ответ (в задачах регресии):
	$$b_{0}(x)=\frac{1}{\ell}\sum_{i=1}^{\ell}y_{i}$$

Допустим, мы построили композицию $a_{N-1}(x)$ из $N-1$ алгоритма, и хотим выбрать следующий базовый алгоритм $b_{N}(x)$ так, чтобы как можно сильнее уменьшить ошибку: $$\sum_{i=1}^{\ell}L(y_{i},a_{N-1}(x_{i})+\gamma_{N}b_{N}(x_{i}))\to\min_{b_{N},\gamma_{N}}$$
Ответим в первую очередь на следующий вопрос: если бы в качестве алгоритма $b_{N}(x)$ мы могли выбрать совершенно любую функцию, то какие значения ей следовало бы принимать на объектах обучающей выборки? Иными словами, нам нужно понять, какие числа $s_{1},\dots,s_{\ell}$ надо выбрать для решения следующей задачи:
$$\sum_{i=1}^{\ell}L(y_{i},a_{N-1}(x_{i})+s_{i})\to\min_{s_{1},\dots,s_{\ell}}$$
Понятно, что можно требовать $s_{i}=y_{i}-a_{N-1}(x_{i})$, но такой подход никак не учитывает особенностей функции потерь $L(y,z)$ и требует лишь точного совпадения предсказаний и истинных ответов. Более разумно потребовать, чтобы сдвиг $s_{i}$ был противоположен производной функции потерь в точке $z=a_{N-1}(x_{i})$:
$$s_{i}=- \frac{\partial L}{\partial z}\bigg|_{x=a_{N-1}(x_{i})}$$
В этом случае мы сдвинемся в сторону скорейшего убывания функции потерь. Заметим, что вектор сдвигов $s=(s_{1},\dots,s_{\ell})$ совпадает с антиградиентом:
$$\left( - \frac{\partial L}{\partial z}\bigg|_{z=a_{N-1}(x_{i})} \right)_{i=1}^{\ell} = - \nabla_{z} \sum_{i=1}^{\ell}L(y_{i},z_{i})|_{z=a_{N-1}(x_{i})} $$
При таком выборе сдвигов $s_{i}$ мы, по сути, сделаем один шаг градиентного спуска, двигаясь в сторону наискорейшего убывания ошибки на обучающей выборке. Отметим, что речь идёт о градиентном спуске в $\ell$-мерном пространстве предсказаний алгоритма на объектах обучающей выборки. Поскольку вектор сдвига будет свой на каждой итерации, правильнее обозначать его как $s_{i}^{(N)}$, но для простоты будем иногда опускать верхний индекс.

Итак, мы поняли, какие значения новый алгоритм должен принимать на объектах обучающей выборки. По данным значениям в конечном числе точек необходимо построить функцию, заданную на всем пространстве объектов. Это классическая задача обучения с учителем, которую мы уже хорошо умеем решать. Один из самых простых функционалов - среднеквадратичная ошибка. Воспользуемся им для поиска базового алгоритма, приближающего градиент функции потерь на обучающей выборке:
$$b_{N}(x)=\arg_{b\in \mathcal{A}}\min \sum_{i=1}^{\ell}(b(x_{i})-s_{i})^{2}$$
Отметим, что здесь мы оптимизируем квадратичную функцию потерь независимо от функционала исходной задачи - вся информация о функции потерь $L$ находится в антиградиенте $s_{i}$, а на данном шаге лишь решается задача аппроксимации функции по $\ell$ точкам. Разумеется, можно использовать и другие функционалы, но среднеквадратичной ошибки, как правило, оказывается достаточно. Ещё одна причина для использования среднеквадратичной ошибки состоит в том, что от алгоритма требуется как можно точнее приблизить направление наискорейшего убывания функционала (то есть направление $(s_{i})_{i}$); совпадение направлений вполне логично оценивать через косинус угла между ними, который напрямую связан со среднеквадратичной ошибкой.

После того, как новый базовый алгоритм найден, можно подобрать коэффициент при нем по аналогии с наискорейшим градиентным спуском:
$$\gamma_{N}=\arg_{\gamma \in \mathbb{R}}\min \sum_{i=1}^{\ell}L(y_{i},a_{N-1}(x_{i})+\gamma b_{N}(x_{i}))$$
Описанный подход с аппроксимацией антиградиента базовыми алгоритмами и называется градиентным бустингом. Дынный метод представляет собой поиск лучшей функции, восстанавливающей истинную зависимость ответов от объектов, в пространстве всех возможных функций. Ищем мы данную функцию с помощью "псевдоградиентного" спуска- каждый шаг делается вдоль направления, задаваемого некоторым базовым алгоритмом. При этом сам базовый алгоритм выбирается так, чтобы как можно лучше приближать антиградиент ошибки на обучающей выборке.
## Регуляризация

#### Сокращение шага

На практике оказывается, что градиентный бустинг быстро стоит композицию, ошибка которой на обучении выходит на асимптоту, после чего начинает настраиваться на шум и переобучаться. Это явление можно объяснить одной из двух причин:
- Если базовые алгоритмы очень простые, то они плохо приближают вектор антиградиента. По сути, добавление такого базового алгоритма будет соответствовать шагу вдоль направления, сильно отличающегося от направления наискорейшего убывания. Соответственно, градиентный бустинг может свестись к случайному блуждению к пространстве.
- Если базовые алгоритмы сложные, то они способны за несколько шагов бустинга идеально подогнаться под обучающую выборку - что, очевидно, будет являться переобучением, связанным с излишней сложностью семейства алгоритмов.

>[!definition] Сокращение шага
> Вместо перехода в оптимальную точку в направлении антиградиента делается укороченный шаг:$$a_{N}=a_{N-1}(x)+\eta\gamma_{N}b_{N}(x),$$
> где $\eta \in(0,1]$ - темп обучения.

Как правило, чем меньше темп обучения, тем лучше качество итоговой композиции. Сокращение шага, по сути, позволяет понизить доверие к направлению, восстановленному базовым алгоритмом.

Также следует обратить внимание на число итераций градиентного бустинга. Хотя ошибка на обучении монотонна стремится к нулю, ошибка на контроле, как правило, начинает увеличивается после определенной итерации. Оптимальное число итераций можно выбирать, например, по отложенной выборке или с помощью кросс-валидации.

#### Стохастический градиентный бустинг

Ещё одним способом улучшения качества градиентного бустинга является внесение рандомизации в процесс обучения базовых алгоритмов. А именно, алгоритм $b_{N}$ обучается не по всей выборке $X$, а лишь по её случайному подмножеству $X^{k}\subset X$. В этом случае понижается уровень шума в обучении, а также повышается эффективность вычислений. Существует рекомендация брать подвыборки, размер вдвое меньше исходной выборки.

## Функция потерь

### Регрессия

При вещественном целевом векторе, как правило, используют квадратичную функцию потерь, формулы для которой уже были приведены выше. Другой вариант - модуль отклонения $L(y,z)=|y-z|$, для которой антиградиент вычисляется по формуле $$s_{i}^{(N)}=-\text{sign}(a_{N-1}(x_{i})-y_{i}).$$
### Классификация

В задаче классификации с двумя классами разумным выбором является логистическая функция потерь: $$L(y,z)=\log(1+\exp(-yz))$$
Задача поиска базового алгоритма с ней принимает вид $$b_{N}=\arg_{b\in \mathcal{A}}\min \sum_{i=1}^{\ell}\left( b(x_{i})- \frac{y_{i}}{1+\exp(y_{i}a_{N-1}(x_{i}))} \right)^{2}. $$
Логистическая функция потерь имеет интересную особенность, связанную со взвешиванием объектов. Заметим, что ошибка на $N$-ой итерации может быть записана как $$Q(a_{N})=\sum_{i=1}^{\ell}\log(1+\exp(-y_{i}a_{N}(x_{i})))=\sum_{i=1}^{\ell}\log(1+\exp(-y_{i}a_{N-1}(x_{i}))\exp(-y_{i}\gamma_{N}b_{N}(x_{i}))).$$
Если отступ $y_{i}a_{N-1}(x_{i})$ на $i$-м объекте большой положительный, то данный объект не будет вносить практически никакого вклада в ошибку, и может быть исключён из всех вычислений на текущей итерации без потерь. Таким образом, величина $$w_{i}^{(N)}=\exp(-y_{i}a_{N-1}(x_{i}))$$
может служить мерой важности объекта $x_{i}$ на $N$-й итерации градиентного бустинга.

## Взвешивание объектов

Одним из первых широко распространённых методов построения композиций является $\text{AdaBoost}$, в котором оптимизируется экспоненциальная функция потерь $L(y,z)=e^{ -yz }$. Благодаря её свойствам удаётся свести задачу поиска базового алгоритма к минимизации доли неверных ответов с весами при объектах. Эти веса возникают и в градиентном бустинге при использовании экспоненциальной функции потерь:
$$L(a,X)=\sum_{i=1}^{\ell}\exp\left( -y_{i}\sum_{n=1}^{N}\gamma_{n}b_{n}(x_{i}) \right).$$
Найдем компоненты её антиградиента после $(N-1)$-й итерации:
$$s_{i}= - \frac{\partial L(y_{i},z)}{\partial z}\bigg|_{z=a_{N-1}(x_{i})}=y_{i}\underbrace{\exp\left( -y_{i}\sum_{n=1}^{N-1}\gamma_{n}b_{n}(x_{i}) \right)}_{w_{i}}.$$
Заметим, что антиградиент представляет собой ответ на объекте, умноженный на его вес. Если все веса будут равны единице, то следующий базовый классификтор будет настраиваться на исходный целевой вектор $(y_{i})_{i=1}^{\ell};$ штраф за выдачу ответа, противоположному правильному, будет равен $4$. Если же какой-то объект будет иметь большой отступ, то его вес окажется близким к нулю, и штраф за выдачу любого ответа равен 1.

Отметим, что многие функционалы ошибки классификации выражаются через отступы объектов:$$L(a_{N-1},X^{\ell})=\sum_{i=1}^{\ell}L(a_{N-1}(x_{i}),y_{i})=\sum_{i=1}^{\ell}\tilde{L}(y_{i},a_{N-1}(x_{i})).$$
В этом случае антиградиент принимает вид $$s_{i}=y_{i}\underbrace{\left( - \frac{\partial L(y_{i}a_{N-1}(x_{i}))}{\partial a_{N-1}(x_{i})} \right)}_{w_{i}},$$
то есть тоже взвешивает ответы с помощью ошибки на них.
## Влияние шума на обучение

Выше мы находили формулу для антиградиента при использовании экспоненциальной функции потерь: $$s_{i}=y_{i}\ \underbrace{\exp\left( -y_{i}\sum_{n=1}^{N-1}\gamma_{n}b_{n}(x_{i}) \right)}_{w_{i}}$$
Заметим, что если отступ на объекте большой и отрицательный, то вес становится очень большим, причём он никак не ограничен сверху. В результате базовый классификатор будет настраиваться исключительно на шумовые объекты, что может привести к неустойчивости его ответов и переобучению.

Рассмотрим теперь логистическую функцию потерь, которая также может использоваться в задачах классификации: $$L(a,X^{\ell})=\sum_{i=1}^{\ell}\log(1+\exp(-y_{i}a(x_{i}))).$$
Найдём её антиградиент после $(N-1)$-го шага:
$$s_{i}= y_{i} \underbrace{ \frac{1}{1+\exp(y_{i}a_{N-1}(x_{i}))} }_{=w_{i}^{(N)}}$$
Теперь веса ограничены сверху единицей. Если отступ на объекте большой отрицателбный, то вес при нём будет близок к единице; если же отступ на объекте близок к нулю, то вес при нем будет примерно равен $\frac{1}{2}$. Таким образом, вес при шумовом объекте будет всего в 2 раза больше, чем вес при нормальных объектах, что не должно сильно повлиять на процесс обучения.