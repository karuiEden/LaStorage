---
title: Бинарные деревья поиска
created: 2025-06-12
tags:
  - dsa
links:
  - "[[Деревья]]"
---
**Определение:** Пусть $NR=\{ k_{i} \}$. 
Тогда бинарное дерево поиска - множество вершин, в котором каждая вершина дерева помечена отдельным ключом, для любой вершины $x$ с ключом $k_{x}:$
	$\forall k_{i}\inЛ[x]:k_{i}\leq k_{x}$
	$\forall k_{i}\inП[x]: k_{i}\geq k_{x}$
, где $Л[x]$ -левое поддерево узла $x$, $П[x]$ - правое поддерево узла $x$.

Типы вершин:
- корень;
- промежуточные вершины;
- листья.

**Определение:** Уровень вершины дерева - расстояние от корня до данной вершины.
**Определение:** Высота дерева - максимальный уровень вершины дерева.
Типы обхода:
- симметричный;
- прямой;
- в глубину.

Операции поиска:
- Поиск элемента по заданному ключу:
```c
Node* search(BST t, int key){
	Node* ptr = t.root;
	while(ptr){
		if (ptr->key == key){
			return ptr;
		}
		if (ptr->key > key){
			ptr = ptr->left;
		} else {
			ptr = ptr->right;
		}
	}
	return nullptr;
}
```
- Поиск минимального и максимального элементов:
```c
int max(Node* root){
	Node *prev = nullptr;
	if (!root){
		return -1;
	}
	while(root){
		prev = root;
		root = root->right;
	}
	return prev->key;
}

int min(Node* root){
	Node *prev = nullptr;
	if (!root){
		return -1;
	}
	while(root){
		prev = root;
		root = root->left;
	}
	return prev->key;
}
```
- Поиск предшествующего и последующего элементов:
```c
int next(Node* n){
	if (n->right) return min(n->right);
	Node* ptr = n->parent;
	while(ptr && ptr->right == n){
		n = ptr;
		ptr = n->parent;
	}
	return ptr;
}

int pred(Node* n){
	if (n->left) return max(n->left);
	Node* ptr = n->parent;
	while(ptr && ptr->left == n){
		n = ptr;
		ptr = n->parent;
	}
	return ptr;
}
```

Операции поиска, определения максимального и минимального элемента, а также предшествующего и последующего в бинарном дереве поиска высоты $h$ могут быть выполнены за время $Ο(h)$. В худшем случае $h=N$, в среднем случае $h \approx \log_{2} N$.

## Операции
### Вставка

```c
int insert(BST t, int key){
	Node* n = new(key);
	if (!t.root){
		t.root = n;
		return 0;
	}
	Node* root = t.root, *prev = nullptr;
	while(root){
		if (root->key == key){
			delete(n);
			return -1;
		}
		prev = root;
		if (root->key > key){
			root = root->left;
		} else{
			root = root->right;
		}
	}
	if (prev->key > key){
		prev->left = n;
	} else{
		prev->right = n;
	}
	return 0;
}
```

Операция вставки в BST высоты $h$ может быть выполнена за время $O(h)$, где $h=N$ в наихудшем случае.

### Удаление
```c
int erase(BST t, int key){
	Node *root = t.root, *prev = nullptr;
	bool flag = true;
	while(root){
		if (root->key == key){
			flag = false;
			break;
		}
		prev = root;
		if (root->key > key){
			root = root->left;
		} else{
			root = root->right;
		}
	}
	if (flag){
		return -1;
	}
	if (!root->left && !root->right){
		if (!prev){
			delete(root);
			t.root = nullptr;
			return 0;
		}
		if (root == prev->left){
			prev->left = nullptr;
		} else {
			prev->right = nullptr;
		}
		delete(root);
		return 0;
	}
	if (!root->left || !root->right){
		Node* child = root->left ? node->left : node->right;
		if (!prev){
			delete(root);
			t.root = child;
			return 0;
		}
		if (prev->left == root){
			prev->left = child;
		} else{
			prev->right = child;
		}
		delete(root);
		return 0;
	}
	if (root->left && root->right){
		Node* replace = root, *prev_r = nullptr;
		while(replace->left){
			prev_r = replace;
			replace = replace->left;
		}
		root->key = replace->key;
		if(!replace->left && !replace->right){
			prev_r->left = nullptr;
		} else {
			prev_r->left = replace->right;
		}
		delete(replace);
		return 0;
	}
}
```

Операция удаления в BST высоты $h$ может быть выполнена за время $O(h)$, где $h=N$ в наихудшем случае.
